# ðŸ”“ BAC Lab Exploitation Guide

This guide provides step-by-step instructions for exploiting the vulnerabilities in the BAC Lab.

## ðŸŽ¯ Prerequisites

1. Start the application: `python app.py`
2. Open browser: `http://127.0.0.1:5000`
3. Login as a regular user: `user1` / `user123`
4. Have access to Burp Suite or browser DevTools (for session cookie capture)

## ðŸ” Important Note

**The admin endpoints are now properly protected!** Normal users will receive `403 Forbidden` errors when trying to access:
- `/admin` - Admin panel
- `/api/admin/settings` - Admin settings API
- `/api/admin/keys` - API keys endpoint
- `/api/admin/users/all` - All users' data endpoint

**However**, these endpoints are vulnerable to **Session Cookie Theft/Replay Attacks**. If you can capture an admin's session cookie from a request, you can use it to impersonate the admin!

## ðŸ› Vulnerability #1: Session Cookie Theft/Replay Attack

### âš ï¸ Important: Admin endpoints are now properly protected!
If you try accessing `/admin` or `/api/admin/*` as a regular user, you'll get `403 Forbidden`.

### Method: Capture Admin's Session Cookie and Replay It

**Step 1: Set up Burp Suite Proxy**
1. Install and configure Burp Suite Community Edition
2. Configure your browser to use Burp's proxy (usually `127.0.0.1:8080`)
3. Install Burp's CA certificate in your browser

**Step 2: Capture Admin's Session Cookie**
1. Open a new incognito/private browser window
2. Login as admin: `admin` / `admin123`
3. While admin is logged in, make any request (e.g., visit `/admin` or `/api/admin/settings`)
4. In Burp Suite, go to the Proxy â†’ HTTP history tab
5. Find the admin's request (look for requests with `/admin` or `/api/admin/`)
6. Right-click on the request â†’ Copy â†’ Copy as cURL (or just view the request)
7. Look for the `Cookie:` header - it contains the session cookie
   - Example: `Cookie: session=eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6ImFkbWluIiwicm9sZSI6ImFkbWluIn0.XXXXXXXX`

**Step 3: Use the Stolen Cookie**
1. In your regular browser (where you're logged in as `user1`), open DevTools (F12)
2. Go to Application/Storage â†’ Cookies
3. Find the `session` cookie
4. Replace its value with the admin's session cookie you captured
5. Refresh the page or visit `/admin`

**Alternative: Using Browser DevTools Network Tab**
1. Have admin login in one browser tab/window
2. Open DevTools (F12) â†’ Network tab
3. Have admin visit `/admin` or make an API call
4. Click on the request in Network tab
5. In Request Headers, copy the `Cookie: session=...` value
6. In your regular user session, replace your session cookie with the admin's cookie

**Why it works:** The endpoints properly check for admin role, but they trust the session cookie. If you can steal an admin's session cookie, you can impersonate them!

---

## ðŸ› Vulnerability #2: Access Admin API Keys & Organization Data

### Using Stolen Admin Cookie

Once you have the admin's session cookie (see Vulnerability #1):

1. **Access Admin API Keys:**
   - Visit: `/api/admin/keys`
   - You'll see all organization API keys and secrets:
     - `ORG_ALPHA_API_KEY_XYZ123`
     - `ORG_BETA_API_KEY_ABC456`
     - `ORG_GAMMA_API_KEY_DEF789`
     - Plus admin API keys from settings

2. **Access All Users' Data:**
   - Visit: `/api/admin/users/all`
   - You'll see all users' sensitive data including:
     - All user accounts (username, email, role)
     - All user data entries (including flags)
     - Complete organization user database

3. **Access Admin Panel:**
   - Visit: `/admin`
   - Full admin dashboard with all settings and flags

**Why it works:** With the admin's session cookie, you are authenticated as admin, so all admin endpoints accept your requests.

## ðŸ› Vulnerability #3: IDOR - Access Other Users' Data (Fixed, but admins can still access)

### Profile Access (Regular Users)
- As `user1`, you can view your own profile: `/profile/YOUR_ID`
- If you try `/profile/1` (admin's profile), you can see basic info but not sensitive data
- User data API now checks ownership: `/api/user/OTHER_ID` returns 403

### Admin Can Access All (Using Stolen Cookie)
- Once you have admin cookie, visit `/api/user/ANY_ID` to access any user's data
- Or use `/api/admin/users/all` to get all users' data at once

---

---

## ðŸ› Vulnerability #4: Privilege Escalation (May still work)

### Method 1: Update Role Endpoint
1. Open browser DevTools Network tab
2. Find the update role form (you might need to add it manually)
3. Send POST request to `/update_role`:
   ```
   POST /update_role
   user_id=2&role=admin
   ```
4. Your role is now admin!

**Why it works:** The endpoint doesn't check if the requester is an admin before allowing role changes.

### Method 2: Direct API Call
```bash
curl -X POST http://127.0.0.1:5000/update_role \
  -H "Cookie: session=YOUR_SESSION_COOKIE" \
  -d "user_id=YOUR_ID&role=admin"
```

---

## ðŸ† Finding All Flags

### Flag 1: User Data Flag
1. Access your own data: `/api/user/YOUR_USER_ID`
2. Look for: `BAC_LAB_USER_DATA`

### Flag 2: Admin Panel Flag
1. **Capture admin's session cookie** (see Vulnerability #1)
2. Use the cookie to access: `/admin`
3. Look for: `BAC_LAB_ADMIN_PANEL_ACCESSED`

### Flag 3: Admin API Keys & Organization Keys
1. **Capture admin's session cookie**
2. Access: `/api/admin/keys`
3. You'll find:
   - `ADMIN_API_KEY_2024_SECRET`
   - Organization API keys: `ORG_ALPHA_API_KEY_XYZ123`, `ORG_BETA_API_KEY_ABC456`, etc.

### Flag 4: All Users' Data
1. **Capture admin's session cookie**
2. Access: `/api/admin/users/all`
3. See all organization users' sensitive data including flags

---

## ðŸ› ï¸ Using Burp Suite

1. Configure browser to use Burp proxy
2. Intercept requests
3. Try modifying:
   - URL parameters (user IDs, role values)
   - POST data (user_id, role)
   - Cookies (session data)
   - Headers

### Example Burp Modifications

**Request to modify:**
```
GET /api/user/1 HTTP/1.1
Cookie: session=...
```

Change to:
```
GET /api/user/2 HTTP/1.1
Cookie: session=...
```

---

## ðŸ“ Testing Checklist

- [ ] Set up Burp Suite proxy
- [ ] Login as admin and capture their session cookie
- [ ] Replace your session cookie with admin's cookie
- [ ] Access admin panel (`/admin`) using stolen cookie
- [ ] Access admin API keys (`/api/admin/keys`) using stolen cookie
- [ ] Access all users' data (`/api/admin/users/all`) using stolen cookie
- [ ] Try accessing admin endpoints as regular user (should get 403)
- [ ] Verify you can access your own data (`/api/user/YOUR_ID`)
- [ ] Verify you cannot access other users' data directly (should get 403)
- [ ] Capture all flags using admin access
- [ ] Document the session cookie theft vulnerability

---

## ðŸ’¡ Pro Tips

1. **Session Cookie Theft is Key** - Admin endpoints are properly protected, so you MUST steal the admin's session cookie
2. **Use Burp Suite Effectively**:
   - Set up proxy properly
   - Enable intercept for admin requests
   - Use "Copy as cURL" to see exact cookie values
   - Use Repeater to test with different cookies
3. **Browser DevTools Alternative**:
   - Network tab shows all cookies in request headers
   - Application tab lets you edit cookies directly
4. **Cookie Format**: Flask session cookies are base64 encoded JSON with a signature
5. **Session Timing**: Make sure admin is still logged in when you steal the cookie (sessions can expire)
6. **Test Multiple Endpoints**: Once you have admin cookie, test all `/api/admin/*` endpoints

---

## ðŸŽ“ Learning Points

1. **Always verify authorization on the server-side**
2. **Never trust client-side checks**
3. **Use proper role-based access control (RBAC)**
4. **Implement proper session validation**
5. **Check ownership before allowing access to resources**
6. **Use indirect object references instead of direct IDs**
7. **Log and monitor unauthorized access attempts**

---

## ðŸ”’ How to Fix Session Cookie Theft Vulnerability

### Fix #1: Secure Session Management
```python
# Use secure session cookies
app.config['SESSION_COOKIE_SECURE'] = True  # HTTPS only
app.config['SESSION_COOKIE_HTTPONLY'] = True  # Prevent JavaScript access
app.config['SESSION_COOKIE_SAMESITE'] = 'Strict'  # CSRF protection
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(minutes=15)  # Short expiry

# Use session tokens instead of storing role in session
# Store a random token in database that maps to user + role
```

### Fix #2: Session Invalidation on Suspicious Activity
```python
# Log IP addresses and invalidate if changed
if session.get('ip_address') != request.remote_addr:
    session.clear()
    return redirect(url_for('login'))

# Add session timeout
if 'last_activity' in session:
    if time.time() - session['last_activity'] > 900:  # 15 minutes
        session.clear()
        return redirect(url_for('login'))
session['last_activity'] = time.time()
```

### Fix #3: Use CSRF Tokens
```python
from flask_wtf.csrf import CSRFProtect
csrf = CSRFProtect(app)

# Include CSRF token in all forms and API requests
```

### Fix #4: Implement Token-Based Auth
```python
# Instead of session-based auth, use JWT tokens
# Tokens should be short-lived and rotated frequently
# Include user ID and role in token, but verify on server-side
```

**Remember:** The current implementation properly checks for admin role, which is good! The vulnerability is in the session management - stolen cookies can be replayed. In real-world scenarios, you'd also need HTTPS, secure cookie flags, and additional session security measures.

---

**Remember:** These vulnerabilities are intentionally included for educational purposes. Always practice responsible disclosure in real-world scenarios!

